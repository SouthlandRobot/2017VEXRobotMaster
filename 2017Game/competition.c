#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    HandL,          sensorPotentiometer)
#pragma config(Sensor, in2,    HandR,          sensorPotentiometer)
#pragma config(Sensor, dgtl1,  SonarA,         sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  SonarB,         sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  H1,             sensorDigitalOut)
#pragma config(Sensor, dgtl6,  H2,             sensorDigitalOut)
#pragma config(Sensor, dgtl7,  HW,             sensorDigitalOut)
#pragma config(Sensor, I2C_1,  FL,             sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  FR,             sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  BL,             sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  BR,             sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  H1,             sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_6,  H2,             sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           FL,            tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port4,           BL,            tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port5,           BR,            tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port6,           AA,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           AB,            tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port8,           AC,            tmotorVex393_MC29, openLoop, encoderPort, I2C_6)
#pragma config(Motor,  port9,           AD,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          FR,            tmotorVex393_HBridge, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
#define BaseFL motor[FL]
#define BaseFR motor[FR]
#define BaseBL motor[BL]
#define BaseBR motor[BR]

#define ArmMotorA motor[AA]
#define ArmMotorB motor[AB]
#define ArmMotorC motor[AC]
#define ArmMotorD motor[AD]

#define HandMotorA SensorValue[H1]
#define HandMotorB SensorValue[H1]
#define HandMotorC SensorValue[H2]
#define HandMotorD SensorValue[H2]
#define MEMORY_SIZE 4096
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;
typedef struct {
	bool motorChange;
	bool armChange;
	bool handChange;
	bool valueChange;
	int lYError;
	int lXError;
	int rYError;
	int rXError;
	int armHoldA;
	int armHoldB;
	int armHoldC;
	int armHoldD;
	float baseRate;
	int rateSetting;
} RobotState;
RobotState this;

void preSetFrontMove(int *array);
void preSetBackMove(int *array);
void preSetLeftMove(int *array);
void preSetRightMove(int *array);

void ArmMotorUpSet(int *array);
void ArmMotorDownSet(int *array);
void HandMotorUpSet(int *array);
void HandMotorDownSet(int *array);
void specialSetMove(int *array);
void preSetRightTrun(int *array);
void preSetLeftTrun(int *array);
void resetFront(int *array);
void resetBack(int *array);
void resetLeft(int *array);
void resetRight(int *array);
void resetArmMotorSet(int *array);
void resetHandMotorSet(int *array);
void resetspecialSet(int *array);
void baseMove();
void resetAll();
int mode;
task displayInfo();
float rate;
float rateSet[]={0.5,1,1.5,2};
bool hwState;
//0:auto|1:manu
//0:Car mode|1:Coordinate mode
//0:Speed control|1:Step mode
//0:low arm state|1:hold arm state|2:changing state
//?
float bat1;
float bat2;
float bat3;
/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDString(0, 0, "System Mode:");
	displayLCDString(1, 0, "autonomous");
	delay(5000);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
  // User control code here, inside the loop
	rate=1;
	this.lYError=vexRT[Ch3];
	this.lXError=vexRT[Ch4];
	this.rYError=vexRT[Ch2];
	this.rXError=vexRT[Ch1];
	this.armHoldA=0;
	this.armHoldB=0;
	this.armHoldC=0;
	this.armHoldD=0;
	this.baseRate=1;
	this.rateSetting=1;
	mode=3;
	startTask(displayInfo);
  while (true)
  {
 		baseMove();
  }
}

void preSetFrontMove(int *array){
	BaseFL=255;
	BaseFR=-255;
	BaseBL=255;
	BaseBR=-255;
	this.motorChange=true;
}
void preSetBackMove(int *array){
	BaseFL=-255;
	BaseFR=255;
	BaseBL=-255;
	BaseBR=255;
	this.motorChange=true;
}
void preSetLeftMove(int *array){
	BaseFL=-255;
	BaseFR=-255;
	BaseBL=255;
	BaseBR=255;
	this.motorChange=true;
}
void preSetRightMove(int *array){
	BaseFL=255;
	BaseFR=255;
	BaseBL=-255;
	BaseBR=-255;
	this.motorChange=true;
}
void preSetRightTrun(int *array){
	BaseFL=255;
	BaseFR=255;
	BaseBL=255;
	BaseBR=255;
	delay(50);
	this.motorChange=true;
}
void preSetLeftTrun(int *array){
	BaseFL=-255;
	BaseFR=-255;
	BaseBL=-255;
	BaseBR=-255;
	delay(50);
	this.motorChange=true;
}
void specialSetMove(int* array){
	BaseFL=array[0]*this.baseRate;
	BaseFR=array[1]*this.baseRate;
	BaseBL=array[2]*this.baseRate;
	BaseBR=array[3]*this.baseRate;
	//this.motorChange=true;
}


void ArmMotorUpSet(int *array){
	ArmMotorA=-255;
	ArmMotorB=255;
	ArmMotorC=-255;
	ArmMotorD=255;
	this.armChange=true;
}
void ArmMotorDownSet(int *array){
	ArmMotorA=-255;
	ArmMotorB=-255;
	ArmMotorC=-255;
	ArmMotorD=-255;
	this.armChange=true;
}
void HandMotorUpSet(int *array){
	HandMotorA=1;
	HandMotorB=1;
	HandMotorC=1;
	HandMotorD=1;
	this.handChange=true;
}
void HandMotorDownSet(int *array){
	HandMotorA=-255;
	HandMotorB=-255;
	HandMotorC=-255;
	HandMotorD=-255;
	this.handChange=true;
}
/*Reset function*/
//not test yet
void resetFront(int *array){
	BaseFL=0;
	BaseFR=0;
	BaseBL=0;
	BaseBR=0;
	this.motorChange=false;
}
void resetBack(int *array){
	resetFront(array);
}
void resetLeft(int *array){
	resetFront(array);
}
void resetRight(int *array){
	resetFront(array);
}
void resetArmMotorSet(int *array){
	ArmMotorA=0;
	ArmMotorB=0;
	ArmMotorC=0;
	ArmMotorD=0;
	this.armChange=false;
}
void resetHandMotorSet(int *array){
	HandMotorA=0;
	HandMotorB=0;
	HandMotorC=0;
	HandMotorD=0;
	this.handChange=false;
}
void resetspecialSet(int *array){
	BaseFL=array[0];
	BaseFR=array[1];
	BaseBL=array[2];
	BaseBR=array[3];
	this.motorChange=false;
}
task displayInfo(){
	int lastMode=-1;
	int count=0;
	float lastValue=-1;
 //Build the value to be displayed
string mainBattery, backupBattery;
	while(true){
		 switch(count){
		    case 0:
		    {
			    if(lastMode!=mode||this.valueChange){


						if(mode==0){
								clearLCDLine(0);
						clearLCDLine(1);
							displayLCDString(0, 0, "System Mode:");
							displayLCDString(1, 0, "Car");
						}
						else if(mode==1){
								clearLCDLine(0);
						clearLCDLine(1);
							displayLCDString(0, 0, "System Mode:");
							displayLCDString(1, 0, "Coordinate");
						}
						else if(mode==3){
								clearLCDLine(0);
						clearLCDLine(1);
							displayLCDString(0, 0, "System Mode:");
							displayLCDString(1, 0, "Locked");
						}
						else if(mode ==4&&this.valueChange){
							clearLCDLine(0);
							clearLCDLine(1);
							displayLCDString(0, 0, "Speed Mode:");
							if(this.rateSetting==0)
								displayLCDString(1, 0, "Slow");
							else if(this.rateSetting==1)
								displayLCDString(1, 0, "Normal");
							else if(this.rateSetting==2)
								displayLCDString(1, 0, "Sport");
							else if(this.rateSetting==3)
								displayLCDString(1, 0, "Full");
							this.valueChange=false;
						}
						lastMode=mode;
					}
				}
		    break;
		    case 1:
		    {
		    	lastMode=-1;
			    clearLCDLine(0);
					clearLCDLine(1);
					displayLCDString(0, 0, "Primary: ");
					sprintf(mainBattery, "%5.4f%c", nImmediateBatteryLevel/1000.0,'V');
					displayNextLCDString(mainBattery);
					displayLCDString(1, 0, "Backup: ");
					sprintf(backupBattery, "%5.4f%c", BackupBatteryLevel/1000.0, 'V');
					displayNextLCDString(backupBattery);
				}
		    break;
		 }
		if(nLCDButtons == leftButton)
       count=0;
     else if(nLCDButtons == rightButton)
       count=1;
	}
}
int signs[]={1,-1,1,-1};
void baseMove(){
	int lY=vexRT[Ch3]-this.lYError;
	int lX=vexRT[Ch4]-this.lXError;
	int rY=vexRT[Ch2]-this.rYError;
	int rX=vexRT[Ch1]-this.rXError;
	if(vexRT[Btn5D]==1&&vexRT[Btn6D]==1){
		mode=3;
		resetAll();
	}
	while(mode==3){
		if(vexRT[Btn5U]==1&&vexRT[Btn6U]==1){
			mode=0;
			SensorValue[HW]=true;
			break;
		}
		else if(vexRT[Btn8D]==1){
			delay(1000);
			if(vexRT[Btn8D]==1){
				mode=4;
			}
		}
		while(mode==4){
		if(vexRT[Btn5D]==1&&vexRT[Btn6D]==1){
			mode=3;
			resetAll();
		}
		else if(vexRT[Btn5U]==1){
			this.rateSetting++;
			this.valueChange=true;
			delay(200);
		}else if(vexRT[Btn5D]==1){
			this.rateSetting--;
			this.valueChange=true;
			delay(200);
		}
		if(this.rateSetting<0)
			this.rateSetting=3;
		else if(this.rateSetting>3)
			this.rateSetting=0;
		rate=rateSet[this.rateSetting];
		this.baseRate=rateSet[this.rateSetting];
		}
	}
	if(vexRT[Btn8L] == 1){
		SensorValue[HW]=true;
	}
	else if(vexRT[Btn8D] == 1){
		SensorValue[HW]=false;
	}
	if(0==0){
		int values[4];
		for(int i=0;i<4;i++){
			values[i]=signs[i]*(lY)+lX;
		}
		specialSetMove(values);
	}

	if(vexRT[Btn5U] == 1){
		SensorValue[H1]=!SensorValue[H1];
		SensorValue[H2]=!SensorValue[H2];
		delay(200);
	}

	if(vexRT[Btn7D] == 1){
		this.lYError=vexRT[Ch3];
		this.lXError=vexRT[Ch4];
		this.rYError=vexRT[Ch2];
		this.rXError=vexRT[Ch1];
		resetAll();
	}

	if(rY!=this.rYError){
		ArmMotorA=-1*(-1*rY)*rate;
		ArmMotorB=(-1*rY)*rate;
		ArmMotorC=-1*(-1*rY)*rate;
		ArmMotorD=(-1*rY)*rate;
	}
	else
		resetArmMotorSet(NULL);
	hwState=SensorValue[HW];
}
void resetAll(){
	resetArmMotorSet(NULL);
	resetFront(NULL);
	resetHandMotorSet(NULL);
}
